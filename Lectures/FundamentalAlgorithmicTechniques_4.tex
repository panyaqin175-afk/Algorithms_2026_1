\documentclass{beamer}
\usepackage[utf8]{inputenc}
\usepackage{url}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{lmodern}
\usepackage{natbib}
\usepackage{tikz}
\usepackage{physics}
\usepackage{graphicx}
\graphicspath{{./images/}}
\usepackage{booktabs}
\usetikzlibrary{mindmap, trees, shadows, shapes, calc, fadings, positioning, 
  decorations.pathreplacing, intersections, arrows}

\usetheme{default}
\usepackage{color}
\definecolor{new_turquoise}{RGB}{40,151,158}
\setbeamercolor{title}{fg=new_turquoise}
\setbeamercolor{frametitle}{fg=new_turquoise}
\setbeamertemplate{itemize item}{\color{new_turquoise}$\blacksquare$}
\setbeamertemplate{itemize subitem}{\color{new_turquoise}$\blacksquare$}
\setbeamertemplate{enumerate item}{\color{new_turquoise}\insertenumlabel}
\setbeamertemplate{enumerate subitem}{\color{new_turquoise}\insertsubenumlabel}
\setbeamertemplate{caption}{\raggedright\insertcaption\par}
\setbeamercolor{section in toc}{fg=new_turquoise}
\setbeamercolor{subsection in toc}{fg=new_turquoise}

\usebackgroundtemplate{
    \includegraphics[width=\paperwidth,height=\paperheight]{figs/slide-title.jpg}
}

\title{\fontsize{49}{7.2}{\bf Fundamental Algorithmic Techniques IV}}
\date{\color{new_turquoise}\today}

\begin{document}
\frame{\titlepage}

\usebackgroundtemplate{
    \includegraphics[width=\paperwidth,height=\paperheight]{figs/slide-pages}
}

\setbeamertemplate{subsection in toc}{
  \color{new_turquoise}$\blacksquare$\color{black}~~\inserttocsubsection
}

\begin{frame}{Outline}
    \tableofcontents
\end{frame}

\section{Heap Sort}

\begin{frame}
    \frametitle{HeapSort}
    \begin{columns}[T]
        \column{0.48\linewidth}
        \small
        Array $\longleftrightarrow$ Complete Binary Tree\\[1em]
        sorts in-place â€” no extra memory needed
        
        \includegraphics[width=\linewidth]{Algos_figs/heapsort.png}\\[1em]
        
        {\bf Root}: index 1 \\[1em]
        
        \begin{itemize}
            \item Parent(i) $\rightarrow \left\lfloor \dfrac{i}{2} \right\rfloor$
            \item Left(i)  $\rightarrow 2i$
            \item Right(i) $\rightarrow 2i + 1$
        \end{itemize}
        
        \column{0.48\linewidth}
        \small
        \bigskip
        Goal: Sorting \\
        $[1, 2, 3, 4, 7, 8, 9, 10, 14, 16]$ or \\
        $[16, 14, 10, 9, 8, 7, 4, 3, 2, 1]$\\[1em]
        
        \begin{center}
            \includegraphics[width=0.45\linewidth]{Algos_figs/sorted_heap.png}%
            \hfill
            \includegraphics[width=0.45\linewidth]{Algos_figs/sorted_heap_2.png}
        \end{center}
        
        \vspace{0.5em}
        
        2 operations on Tree:
        \begin{itemize}
            \item \texttt{heapify} or max/min heap
            \item \texttt{swap}
        \end{itemize}
        
        \href{https://www.youtube.com/watch?v=2DmK_H7IdTo}{\underline{quick video link}}
    \end{columns}
\end{frame}

\begin{frame}
    \frametitle{Core Operations in Heapsort}
    \textbf{heapify} (max-heapify):
    \begin{itemize}
        \item Restores max-heap property after root removal
        \item Compares parent with children $\rightarrow$ swaps if needed
        \item Recurses \textbf{downward} toward leaves
        \item Takes $O(\log n)$ time (at most $2 \lfloor \log_2 n \rfloor$ comparisons)
    \end{itemize}
    
    \textbf{swap}:
    \begin{itemize}
        \item Exchanges root ($A[0]$) with last element ($A[n-1]$)
        \item Reduces heap size by 1
        \item $O(1)$ operation
    \end{itemize}
    
    \vspace{1em}
    \footnotesize \textit{Example: $[3,7,1,8,2,5,9,4,6]$}
\end{frame}

\section{Merge Sort}

\begin{frame}
    \frametitle{MergeSort}
    \begin{algorithmic}[1]
        \Function{MergeSort}{$A, p, r$}
            \If{$p < r$}
                \State $q \gets \left\lfloor \dfrac{p + r}{2} \right\rfloor$
                \State \Call{MergeSort}{$A, p, q$}
                \State \Call{MergeSort}{$A, q + 1, r$}
                \State \Call{Merge}{$A, p, q, r$}
            \EndIf
        \EndFunction
    \end{algorithmic}
\end{frame}

\section{Quick Sort}

\begin{frame}
    \frametitle{QuickSort}
    \begin{columns}[T]
        \column{0.48\linewidth}
        \centering
        \includegraphics[width=\linewidth]{Algos_figs/Quick_sort_algorithm.png}\\[0.5em]
        \footnotesize Quicksort Algorithm
        
        \column{0.48\linewidth}
        \small
        \begin{algorithmic}[1]
            \Function{Quicksort}{$A, p, r$}
                \If{$p < r$}
                    \State $q \gets \Call{Partition}{A, p, r}$
                    \State \Call{Quicksort}{$A, p, q - 1$}
                    \State \Call{Quicksort}{$A, q + 1, r$}
                \EndIf
            \EndFunction
        \end{algorithmic}
    \end{columns}
\end{frame}

\section{Analysis of Sorting Algorithms}

\begin{frame}
    \frametitle{Problem Space Reduction}
    {\bf Space of permutations} for array $v$ of size $n$: 
    \[
    \approx n!
    \]
    
    \bigskip
    {\bf Idea:} Reduce permutation space via divide-and-conquer transformations.
    
    \bigskip
    {\bf MergeSort heuristic:} 
    Merging two sorted subarrays of size $n/2$ reduces uncertainty by combining two independent orderings. 
    With $\approx \log_2 n$ levels of recursion and $O(n)$ work per level:
    \[
    \mathcal{O}(n \log n)
    \]
\end{frame}

\begin{frame}
    \frametitle{Analysis of Merge Sort}
    Simplest analysis for sorting algorithms!
    
    \[
    T(n) = 2T(n/2) + \mathcal{O}(n)
    \]
    
    \begin{itemize}
        \item 2 subproblems of size $n/2$, $c_{\text{crit}} = \log_2 2 = 1$
        \item Work $f(n) = \mathcal{O}(n)$, $c = 1$
    \end{itemize}
    
    \bigskip
    Applying the Master Theorem (balanced case $c_{\text{crit}} = c$):
    \[
    T(n) = \Theta(n^{c_{\text{crit}}} \log n) = \Theta(n \log n)
    \]
\end{frame}

\begin{frame}
    \frametitle{Analysis of Quick Sort}
    \[
    T(n) = T(r - 1) + T(n - r) + \mathcal{O}(n),
    \]
    where $1 \leq r \leq n$ is the pivot position after partitioning.
    
    \bigskip
    {\bf Analysis:}
    \begin{itemize}
        \item \textbf{Balanced:} $T(n) \approx 2T(n/2) + \mathcal{O}(n)$ $\Rightarrow$ $\mathcal{O}(n \log n)$
        \item \textbf{Unbalanced:} $T(n) \approx T(n - 1) + \mathcal{O}(n)$ $\Rightarrow$ $\mathcal{O}(n^2)$
        \item \textbf{Average case:} Close to balanced $\Rightarrow$ $\mathcal{O}(n \log n)$
    \end{itemize}
    
    \bigskip
    {\bf Improved pivots:} random selection or median-of-three (first, middle, last)
\end{frame}

\begin{frame}
    \frametitle{Analysis of Heap Sort}
    Master Theorem doesn't apply!
    \begin{itemize}
        \item Subproblems have \textbf{different sizes} (not $n/b$)
        \item General form: $T(n) = T(n-1) + f(n)$, not $a \cdot T(n/b)$
    \end{itemize}
    
    \bigskip
    {\bf Instead:}
    \begin{enumerate}
        \item Sorting phase: $hs(n) = hs(n-1) + \text{heapify}(n) + \mathcal{O}(1)$
        \item Base: $hs(1) = \mathcal{O}(1)$
        \item $\text{heapify}(i) = \mathcal{O}(\log i)$ (height of subtree)
    \end{enumerate}
    
    \[
    hs(n) = \mathcal{O}(1) + \sum_{i=2}^{n} \mathcal{O}(\log i) = \mathcal{O}\left(\sum_{i=1}^{n} \log i\right) = \mathcal{O}(\log n!) = \Theta(n \log n)
    \]
    (using $\log n! = \Theta(n \log n)$ via Stirling's approximation)
\end{frame}

\end{document}
